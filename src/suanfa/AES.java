/**
 * AES.java	  V1.0   2018年11月9日 上午9:14:19
 *
 * Copyright 2018 FUJIAN FUJITSU COMMUNICATION SOFTWARE CO., LTD. All rights reserved.
 *
 * Modification history(By    Time    Reason):
 * 
 * Description:
 */

package suanfa;

public class AES {
	/**
	 * AES:算法（典型的对称加密算法）
	 * 		:是可逆的，主要作用是保证私密信息不被泄露
	 * 1.密钥:
	 * 		密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类加密算法
	 * 		对明文的加密和密文的解密需要使用同一个密钥
	 * 		AES支持三种长度的密钥：
	 * 		128位，192位，256位
	 * 		AES128:10轮
	 * 		AES192:12轮
	 * 		AES256:14轮
	 * 2.填充:
	 * 		分组加密	：
	 * 				AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一段密文，而是吧明文
	 * 				拆分成一个个独立的英文块，每一个明文块的长度是128bit。这些明文块经过AES加密
	 * 				器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。
	 * 		假如一段明文长度是192bit，如果按照每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足
	 * 		128bit,这时候就需要对明文块进行填充。
	 * 		填充算法：
	 * 		NoPadding
	 * 			不做任何填充，但是要求明文必须是16字节的整数倍。
	 * 		PKCS5Padding（默认）
	 * 			如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少
	 * 			的字符数。
	 * 		ISO10126Padding
	 * 			如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，最后一个字符等于缺少的
	 * 			字符数，其他字符填充随机数。
	 * 3.模式:
	 * 		AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：
	 * 		
	 * 		ECB,CBC,CTR,CFB,OFB
	 * 
	 * 		ECB:电码本模式
	 * 
	 *		CBC：密码分组链接模式
	 *
	 *		CTR: 计算器模式
	 *
	 *		CFB:密码反馈模式
	 *
	 *		OFB:输出反馈模式
	 * AES算法的底层原理
	 * 		AES加密不是一次把明文变成密文，而是先后经过很多轮加密
	 * 		具体分为多少轮呢？
	 * 			初始轮（Initial Round）  1次
	 * 			普通轮(Rounds)          N次
	 * 			最终轮(Final Round)     1次
	 * 		AES的Key支持三种长度：AES128,AES192,AES256.Key的长度决定了AES加密的轮数。
	 * 		不同阶段的Round有不同的处理步骤：
	 * 			initial Round只有一个步骤：
	 * 				加轮密钥（AddRoundKey）
	 * 			Rounds有四个步骤:
	 * 				字节代替（SubBytes）
	 * 				行移位（ShiftRows）
	 * 				列混淆（MixColumns）
	 * 				加轮密钥(AddRoundKey)
	 * 			最终轮有三个步骤:
	 * 				字节代替(SubBytes)
	 * 				行移位(ShiftRows)
	 * 				加轮密钥(AddRoundsKey)
	 * 		1.字节代替（SubBytes）
	 * 			首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列4X4的二维数组。
	 * 			所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节，替代的依据是
	 * 			什么呢？依据一个被称为S盒的16X16大小的二维常量数组。
	 * 			
	 * 		2.行移位(ShiftRows)
	 * 			第一行不变
	 * 			第二行循环左移1个字节
	 * 			第三行循环左移2个字节
	 * 			地四行循环左移3个字节
	 * 		3.列混淆（MixCloumn）
	 * 			这一步，输入数组的每一列要和一个名为修补矩阵的二维常量数组做矩阵相乘
	 * 			得到对应的输出列。
	 * 		4.加轮密钥(AddRoundKey)
	 * 			这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让
	 * 			输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成
	 * 			了输出值b[i,j]
	 * 			ps：加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念:扩展密钥
	 * 		5.扩展密钥(KeyExpansions)
	 * 			AES源代码中用长度4x4x(10+1)字节的数组W来存储所有轮的密钥。W{0-15}的值
	 * 			等同于原始密钥的值，用于为初始轮来做处理。
	 * 			后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，知道数组W的所有元素都
	 * 			赋值完成。
	 * 			w数组中，W{0-15}用于初始轮的处理，W{16-31}用于第一轮的处理，W{32-47}
	 * 			用于第二轮的处理。。。。一直到W{160-175}用于最终轮的处理。
	 * 
	 * 	AES解密流程
	 * 		把加密流程倒置过来，顺序变为最终轮――》普通轮――》初始轮。扩展密钥的使用顺序也
	 * 		和加密相反。
	 * 		
	 */	
	/**
	 * MD5,SHA:摘要算法是不可逆的，他的主要作用是对信息一致性和完整性进行校验
	 */
}
